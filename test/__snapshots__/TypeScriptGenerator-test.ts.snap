// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ConditionField.graphql
import { FragmentRefs } from "relay-runtime";
export type ConditionField = {
    readonly id?: string;
    readonly " $refType": "ConditionField";
};
export type ConditionField$data = ConditionField;
export type ConditionField$key = {
    readonly " $data"?: ConditionField$data;
    readonly " $fragmentRefs": FragmentRefs<"ConditionField">;
};


// NestedCondition.graphql
import { FragmentRefs } from "relay-runtime";
export type NestedCondition = {
    readonly id?: string;
    readonly " $refType": "NestedCondition";
};
export type NestedCondition$data = NestedCondition;
export type NestedCondition$key = {
    readonly " $data"?: NestedCondition$data;
    readonly " $fragmentRefs": FragmentRefs<"NestedCondition">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: derived-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query QueryWithConnectionField($id: ID!) {
  feedback: node(id: $id) {
    ...FeedbackComments_feedback
  }
}

fragment FeedbackComments_feedback on Feedback {
  comments(first: 10) @connection_resolver(label: "FeedbackComments_feedback") {
    count
    edges {
      node {
        id
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// QueryWithConnectionField.graphql
import { FragmentRefs } from "relay-runtime";
export type QueryWithConnectionFieldVariables = {
    id: string;
};
export type QueryWithConnectionFieldResponse = {
    readonly feedback: {
        readonly " $fragmentRefs": FragmentRefs<"FeedbackComments_feedback">;
    } | null;
};
export type QueryWithConnectionField = {
    readonly response: QueryWithConnectionFieldResponse;
    readonly variables: QueryWithConnectionFieldVariables;
};


// FeedbackComments_feedback.graphql
import { FragmentRefs } from "relay-runtime";
export type FeedbackComments_feedback = {
    readonly comments: {
        readonly count: number | null;
        readonly __connection?: ConnectionReference<{
            readonly node: {
                readonly id: string;
                readonly __id: string;
            } | null;
            readonly __id: string;
        }>;
    } | null;
    readonly " $refType": "FeedbackComments_feedback";
};
export type FeedbackComments_feedback$data = FeedbackComments_feedback;
export type FeedbackComments_feedback$key = {
    readonly " $data"?: FeedbackComments_feedback$data;
    readonly " $fragmentRefs": FragmentRefs<"FeedbackComments_feedback">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on User {
  __typename
}

fragment UserFrag2 on User {
  __typename
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import { FragmentRefs } from "relay-runtime";
export type FragmentSpread = {
    readonly id: string;
    readonly justFrag: {
        readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
    } | null;
    readonly fragAndField: {
        readonly uri: string | null;
        readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
    } | null;
    readonly " $fragmentRefs": FragmentRefs<"OtherFragment" | "UserFrag1" | "UserFrag2">;
    readonly " $refType": "FragmentSpread";
};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
    readonly " $data"?: FragmentSpread$data;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
};


// ConcreateTypes.graphql
import { FragmentRefs } from "relay-runtime";
export type ConcreateTypes = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly " $fragmentRefs": FragmentRefs<"PageFragment">;
    } | {
        readonly __typename: "User";
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": "ConcreateTypes";
};
export type ConcreateTypes$data = ConcreateTypes;
export type ConcreateTypes$key = {
    readonly " $data"?: ConcreateTypes$data;
    readonly " $fragmentRefs": FragmentRefs<"ConcreateTypes">;
};


// PictureFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PictureFragment = {
    readonly __typename: "Image";
    readonly " $refType": "PictureFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "PictureFragment";
};
export type PictureFragment$data = PictureFragment;
export type PictureFragment$key = {
    readonly " $data"?: PictureFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
};


// OtherFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type OtherFragment = {
    readonly __typename: string;
    readonly " $refType": "OtherFragment";
};
export type OtherFragment$data = OtherFragment;
export type OtherFragment$key = {
    readonly " $data"?: OtherFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"OtherFragment">;
};


// PageFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PageFragment = {
    readonly __typename: "Page";
    readonly " $refType": "PageFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "PageFragment";
};
export type PageFragment$data = PageFragment;
export type PageFragment$key = {
    readonly " $data"?: PageFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PageFragment">;
};


// UserFrag1.graphql
import { FragmentRefs } from "relay-runtime";
export type UserFrag1 = {
    readonly __typename: "User";
    readonly " $refType": "UserFrag1";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "UserFrag1";
};
export type UserFrag1$data = UserFrag1;
export type UserFrag1$key = {
    readonly " $data"?: UserFrag1$data;
    readonly " $fragmentRefs": FragmentRefs<"UserFrag1">;
};


// UserFrag2.graphql
import { FragmentRefs } from "relay-runtime";
export type UserFrag2 = {
    readonly __typename: "User";
    readonly " $refType": "UserFrag2";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "UserFrag2";
};
export type UserFrag2$data = UserFrag2;
export type UserFrag2$key = {
    readonly " $data"?: UserFrag2$data;
    readonly " $fragmentRefs": FragmentRefs<"UserFrag2">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InlineFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragment = {
    readonly id: string;
    readonly name?: string | null;
    readonly message?: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "InlineFragment";
};
export type InlineFragment$data = InlineFragment;
export type InlineFragment$key = {
    readonly " $data"?: InlineFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragment">;
};


// InlineFragmentWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentWithOverlappingFields";
};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
    readonly " $data"?: InlineFragmentWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
};


// InlineFragmentConditionalID.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentConditionalID = {
    readonly id?: string;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentConditionalID";
};
export type InlineFragmentConditionalID$data = InlineFragmentConditionalID;
export type InlineFragmentConditionalID$key = {
    readonly " $data"?: InlineFragmentConditionalID$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentConditionalID">;
};


// InlineFragmentKitchenSink.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentKitchenSink = {
    readonly actor: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
            readonly width?: number | null;
            readonly height?: number | null;
        } | null;
        readonly name?: string | null;
        readonly " $fragmentRefs": FragmentRefs<"SomeFragment">;
    } | null;
    readonly " $refType": "InlineFragmentKitchenSink";
};
export type InlineFragmentKitchenSink$data = InlineFragmentKitchenSink;
export type InlineFragmentKitchenSink$key = {
    readonly " $data"?: InlineFragmentKitchenSink$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentKitchenSink">;
};


// SomeFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type SomeFragment = {
    readonly __typename: "User";
    readonly " $refType": "SomeFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "SomeFragment";
};
export type SomeFragment$data = SomeFragment;
export type SomeFragment$key = {
    readonly " $data"?: SomeFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"SomeFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedField.graphql
import { FragmentRefs } from "relay-runtime";
export type LinkedField = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
    } | null;
    readonly hometown: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
        } | null;
    } | null;
    readonly actor: {
        readonly id: string;
    } | null;
    readonly " $refType": "LinkedField";
};
export type LinkedField$data = LinkedField;
export type LinkedField$key = {
    readonly " $data"?: LinkedField$data;
    readonly " $fragmentRefs": FragmentRefs<"LinkedField">;
};


// UnionTypeTest.graphql
export type UnionTypeTestVariables = {};
export type UnionTypeTestResponse = {
    readonly neverNode: ({
        readonly __typename: "FakeNode";
        readonly id: string;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
};
export type UnionTypeTest = {
    readonly response: UnionTypeTestResponse;
    readonly variables: UnionTypeTestVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type NameRendererFragment = {
    readonly id: string;
    readonly nameRenderer: {
        readonly __fragmentPropName?: string | null;
        readonly __module_component?: string | null;
        readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name" | "MarkdownUserNameRenderer_name">;
    } | null;
    readonly " $refType": "NameRendererFragment";
};
export type NameRendererFragment$data = NameRendererFragment;
export type NameRendererFragment$key = {
    readonly " $data"?: NameRendererFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"NameRendererFragment">;
};


// PlainUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "PlainUserNameRenderer_name";
};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
    readonly " $data"?: PlainUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name">;
};


// MarkdownUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": "MarkdownUserNameRenderer_name";
};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
    readonly " $data"?: MarkdownUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"MarkdownUserNameRenderer_name">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererQuery.graphql
import { FragmentRefs } from "relay-runtime";
export type NameRendererQueryVariables = {};
export type NameRendererQueryResponse = {
    readonly me: {
        readonly nameRenderer: {
            readonly __fragmentPropName?: string | null;
            readonly __module_component?: string | null;
            readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name" | "MarkdownUserNameRenderer_name">;
        } | null;
    } | null;
};
export type NameRendererQuery = {
    readonly response: NameRendererQueryResponse;
    readonly variables: NameRendererQueryVariables;
};


// PlainUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "PlainUserNameRenderer_name";
};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
    readonly " $data"?: PlainUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name">;
};


// MarkdownUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": "MarkdownUserNameRenderer_name";
};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
    readonly " $data"?: MarkdownUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"MarkdownUserNameRenderer_name">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) {
  commentCreate(input: $input) {
    comment {
      id
      name
      friends(first: $first, orderby: $orderBy) {
        count
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
            readonly name: string | null;
            readonly friends: {
                readonly count: number | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InputHasArray.graphql
export type UpdateAllSeenStateInput = {
    readonly clientMutationId?: string | null;
    readonly storyIds?: ReadonlyArray<string | null> | null;
};
export type InputHasArrayVariables = {
    input?: UpdateAllSeenStateInput | null;
};
export type InputHasArrayResponse = {
    readonly viewerNotificationsUpdateAllSeenState: {
        readonly stories: ReadonlyArray<{
            readonly actorCount: number | null;
        } | null> | null;
    } | null;
};
export type InputHasArrayRawResponse = {
    readonly viewerNotificationsUpdateAllSeenState: ({
        readonly stories: ReadonlyArray<({
            readonly actorCount: number | null;
            readonly id: string | null;
        }) | null> | null;
    }) | null;
};
export type InputHasArray = {
    readonly response: InputHasArrayResponse;
    readonly variables: InputHasArrayVariables;
    readonly rawResponse: InputHasArrayRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
export type UpdateAllSeenStateInput = {
    readonly clientMutationId?: string | null;
    readonly storyIds?: ReadonlyArray<string | null> | null;
};
export type TestVariables = {
    input?: UpdateAllSeenStateInput | null;
};
export type TestResponse = {
    readonly viewerNotificationsUpdateAllSeenState: {
        readonly stories: ReadonlyArray<{
            readonly foos: ReadonlyArray<{
                readonly bar: string | null;
            } | null> | null;
        } | null> | null;
    } | null;
};
export type TestRawResponse = {
    readonly viewerNotificationsUpdateAllSeenState: ({
        readonly stories: ReadonlyArray<({
            readonly id: string | null;
            readonly foos?: ReadonlyArray<({
                readonly bar: string | null;
            }) | null> | null;
        }) | null> | null;
    }) | null;
};
export type Test = {
    readonly response: TestResponse;
    readonly variables: TestVariables;
    readonly rawResponse: TestRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-enums-on-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            id
            __typename
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  profilePicture2 {
    test_enums
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type TestEnums = "mark" | "zuck" | "%future added value";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly friends: {
                readonly edges: ReadonlyArray<{
                    readonly node: {
                        readonly id: string;
                        readonly __typename: string;
                        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
                    } | null;
                } | null> | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutationRawResponse = {
    readonly commentCreate: ({
        readonly comment: ({
            readonly friends: ({
                readonly edges: ReadonlyArray<({
                    readonly node: ({
                        readonly id: string;
                        readonly __typename: "User";
                        readonly name: string | null;
                        readonly lastName: string | null;
                        readonly profilePicture2: ({
                            readonly test_enums: TestEnums | null;
                        }) | null;
                    }) | null;
                }) | null> | null;
            }) | null;
            readonly id: string | null;
        }) | null;
    }) | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
    readonly rawResponse: CommentCreateMutationRawResponse;
};


// FriendFragment.graphql
export type TestEnums = "mark" | "zuck" | "%future added value";
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name: string | null;
    readonly lastName: string | null;
    readonly profilePicture2: {
        readonly test_enums: TestEnums | null;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-nested-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            lastName
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  feedback {
    ...FeedbackFragment
  }
}

fragment FeedbackFragment on Feedback {
  id
  name
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly friends: {
                readonly edges: ReadonlyArray<{
                    readonly node: {
                        readonly lastName: string | null;
                        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
                    } | null;
                } | null> | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutationRawResponse = {
    readonly commentCreate: ({
        readonly comment: ({
            readonly friends: ({
                readonly edges: ReadonlyArray<({
                    readonly node: ({
                        readonly lastName: string | null;
                        readonly name: string | null;
                        readonly feedback: ({
                            readonly id: string;
                            readonly name: string | null;
                        }) | null;
                        readonly id: string | null;
                    }) | null;
                }) | null> | null;
            }) | null;
            readonly id: string | null;
        }) | null;
    }) | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
    readonly rawResponse: CommentCreateMutationRawResponse;
};


// FriendFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name: string | null;
    readonly lastName: string | null;
    readonly feedback: {
        readonly " $fragmentRefs": FragmentRefs<"FeedbackFragment">;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};


// FeedbackFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FeedbackFragment = {
    readonly id: string;
    readonly name: string | null;
    readonly " $refType": "FeedbackFragment";
};
export type FeedbackFragment$data = FeedbackFragment;
export type FeedbackFragment$key = {
    readonly " $data"?: FeedbackFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FeedbackFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-response-on-inline-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
  commentCreate(input: $input) {
    viewer {
      actor {
        ...InlineFragmentWithOverlappingFields
      }
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly viewer: {
            readonly actor: {
                readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
            } | null;
        } | null;
    } | null;
};
export type TestMutationRawResponse = {
    readonly commentCreate: ({
        readonly viewer: ({
            readonly actor: ({
                readonly __typename: "User";
                readonly id: string | null;
                readonly hometown: ({
                    readonly id: string;
                    readonly name: string | null;
                }) | null;
            } | {
                readonly __typename: "Page";
                readonly id: string | null;
                readonly name: string | null;
                readonly hometown: ({
                    readonly id: string;
                    readonly message: ({
                        readonly text: string | null;
                    }) | null;
                }) | null;
            } | {
                readonly __typename: string | null;
                readonly id: string | null;
            }) | null;
        }) | null;
    }) | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
    readonly rawResponse: TestMutationRawResponse;
};


// InlineFragmentWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentWithOverlappingFields";
};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
    readonly " $data"?: InlineFragmentWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// PluralFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PluralFragment = ReadonlyArray<{
    readonly id: string;
    readonly " $refType": "PluralFragment";
}>;
export type PluralFragment$data = PluralFragment;
export type PluralFragment$key = ReadonlyArray<{
    readonly " $data"?: PluralFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PluralFragment">;
}>;

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: query-with-defer.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(key: "TestDefer_friends", initial_count: 0) {
        edges {
          node {
            actor {
              name
            }
          }
        }
      }
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestDefer.graphql
export type TestDeferVariables = {};
export type TestDeferResponse = {
    readonly node: {
        readonly name?: string | null;
        readonly friends?: {
            readonly edges: ReadonlyArray<{
                readonly node: {
                    readonly actor: {
                        readonly name: string | null;
                    } | null;
                } | null;
            } | null> | null;
        } | null;
    } | null;
};
export type TestDeferRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
        readonly friends: ({
            readonly edges: ReadonlyArray<({
                readonly node: ({
                    readonly actor: ({
                        readonly __typename: string | null;
                        readonly name: string | null;
                        readonly id: string | null;
                    }) | null;
                    readonly id: string | null;
                    readonly __typename: "User";
                }) | null;
                readonly cursor: string | null;
            }) | null> | null;
            readonly pageInfo: ({
                readonly endCursor: string | null;
                readonly hasNextPage: boolean | null;
            }) | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type TestDefer = {
    readonly response: TestDeferResponse;
    readonly variables: TestDeferVariables;
    readonly rawResponse: TestDeferRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedHandleField.graphql
export type LinkedHandleFieldVariables = {
    id: string;
};
export type LinkedHandleFieldResponse = {
    readonly node: {
        readonly friends?: {
            readonly count: number | null;
        } | null;
    } | null;
};
export type LinkedHandleFieldRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly friends: ({
            readonly count: number | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type LinkedHandleField = {
    readonly response: LinkedHandleFieldResponse;
    readonly variables: LinkedHandleFieldVariables;
    readonly rawResponse: LinkedHandleFieldRawResponse;
};


// ScalarHandleField.graphql
export type ScalarHandleFieldVariables = {
    id: string;
};
export type ScalarHandleFieldResponse = {
    readonly node: {
        readonly name?: string | null;
    } | null;
};
export type ScalarHandleFieldRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type ScalarHandleField = {
    readonly response: ScalarHandleFieldResponse;
    readonly variables: ScalarHandleFieldVariables;
    readonly rawResponse: ScalarHandleFieldRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
import { FragmentRefs } from "relay-runtime";
export type ExampleQueryVariables = {
    id: string;
    condition: boolean;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
    } | null;
};
export type ExampleQueryRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name?: string | null;
        readonly lastName?: string | null;
        readonly feedback?: ({
            readonly id: string;
            readonly name: string | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
    readonly rawResponse: ExampleQueryRawResponse;
};


// FriendFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name?: string | null;
    readonly lastName?: string | null;
    readonly feedback?: {
        readonly id: string;
        readonly name: string | null;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestStream.graphql
export type TestStreamVariables = {};
export type TestStreamResponse = {
    readonly node: {
        readonly name?: string | null;
        readonly friends?: {
            readonly edges: ReadonlyArray<{
                readonly node: {
                    readonly id: string;
                } | null;
            } | null> | null;
        } | null;
    } | null;
};
export type TestStreamRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
        readonly friends: ({
            readonly edges: ReadonlyArray<({
                readonly node: ({
                    readonly id: string;
                    readonly __typename: "User";
                }) | null;
                readonly cursor: string | null;
            }) | null> | null;
            readonly pageInfo: ({
                readonly endCursor: string | null;
                readonly hasNextPage: boolean | null;
            }) | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type TestStream = {
    readonly response: TestStreamResponse;
    readonly variables: TestStreamVariables;
    readonly rawResponse: TestStreamRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import { FragmentRefs } from "relay-runtime";
export type FragmentSpread = {
    readonly id: string;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
    readonly " $refType": "FragmentSpread";
};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
    readonly " $data"?: FragmentSpread$data;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type RefetchableFragment = {
    readonly id: string;
    readonly fragAndField: {
        readonly uri: string | null;
    } | null;
    readonly " $refType": "RefetchableFragment";
};
export type RefetchableFragment$data = RefetchableFragment;
export type RefetchableFragment$key = {
    readonly " $data"?: RefetchableFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"RefetchableFragment">;
};


// RefetchableFragmentQuery.graphql
import { FragmentReference } from "relay-runtime";
import { FragmentRefs } from "relay-runtime";
export type RefetchableFragmentQueryVariables = {
    id: string;
};
export type RefetchableFragmentQueryResponse = {
    readonly node: {
        readonly " $fragmentRefs": FragmentRefs<"RefetchableFragment">;
    } | null;
};
export type RefetchableFragmentQuery = {
    readonly response: RefetchableFragmentQueryResponse;
    readonly variables: RefetchableFragmentQueryVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: roots.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) {
  node(id: $id) {
    id
  }
}

fragment ExampleFragment on User {
  id
}

mutation TestMutation($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    comment {
      id
    }
  }
}

subscription TestSubscription($input: FeedbackLikeInput) {
  feedbackLikeSubscribe(input: $input) {
    feedback {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
export type ExampleQueryVariables = {
    id: string;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly id: string;
    } | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
};


// ExampleFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type ExampleFragment = {
    readonly id: string;
    readonly " $refType": "ExampleFragment";
};
export type ExampleFragment$data = ExampleFragment;
export type ExampleFragment$key = {
    readonly " $data"?: ExampleFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"ExampleFragment">;
};


// TestMutation.graphql
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
};


// TestSubscription.graphql
export type FeedbackLikeInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
};
export type TestSubscriptionVariables = {
    input?: FeedbackLikeInput | null;
};
export type TestSubscriptionResponse = {
    readonly feedbackLikeSubscribe: {
        readonly feedback: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestSubscription = {
    readonly response: TestSubscriptionResponse;
    readonly variables: TestSubscriptionVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ScalarField.graphql
export type PersonalityTraits = "CHEERFUL" | "DERISIVE" | "HELPFUL" | "SNARKY" | "%future added value";
import { FragmentRefs } from "relay-runtime";
export type ScalarField = {
    readonly id: string;
    readonly name: string | null;
    readonly websites: ReadonlyArray<string | null> | null;
    readonly traits: ReadonlyArray<PersonalityTraits | null> | null;
    readonly aliasedLinkedField: {
        readonly aliasedField: number | null;
    } | null;
    readonly screennames: ReadonlyArray<{
        readonly name: string | null;
        readonly service: string | null;
    } | null> | null;
    readonly " $refType": "ScalarField";
};
export type ScalarField$data = ScalarField;
export type ScalarField$key = {
    readonly " $data"?: ScalarField$data;
    readonly " $fragmentRefs": FragmentRefs<"ScalarField">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInsideWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameInsideWithOverlappingFields = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": "TypenameInsideWithOverlappingFields";
};
export type TypenameInsideWithOverlappingFields$data = TypenameInsideWithOverlappingFields;
export type TypenameInsideWithOverlappingFields$key = {
    readonly " $data"?: TypenameInsideWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameInsideWithOverlappingFields">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInside.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameInside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameInside";
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameInside";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "TypenameInside";
};
export type TypenameInside$data = TypenameInside;
export type TypenameInside$key = {
    readonly " $data"?: TypenameInside$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameInside">;
};


// TypenameOutside.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameOutside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameOutside";
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameOutside";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "TypenameOutside";
};
export type TypenameOutside$data = TypenameOutside;
export type TypenameOutside$key = {
    readonly " $data"?: TypenameOutside$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameOutside">;
};


// TypenameOutsideWithAbstractType.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameOutsideWithAbstractType = {
    readonly __typename: string;
    readonly username?: string | null;
    readonly address?: {
        readonly city: string | null;
        readonly country: string | null;
        readonly street?: string | null;
    } | null;
    readonly firstName?: string | null;
    readonly " $refType": "TypenameOutsideWithAbstractType";
};
export type TypenameOutsideWithAbstractType$data = TypenameOutsideWithAbstractType;
export type TypenameOutsideWithAbstractType$key = {
    readonly " $data"?: TypenameOutsideWithAbstractType$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameOutsideWithAbstractType">;
};


// TypenameWithoutSpreads.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithoutSpreads = {
    readonly firstName: string | null;
    readonly __typename: "User";
    readonly " $refType": "TypenameWithoutSpreads";
};
export type TypenameWithoutSpreads$data = TypenameWithoutSpreads;
export type TypenameWithoutSpreads$key = {
    readonly " $data"?: TypenameWithoutSpreads$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithoutSpreads">;
};


// TypenameWithoutSpreadsAbstractType.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithoutSpreadsAbstractType = {
    readonly __typename: string;
    readonly id: string;
    readonly " $refType": "TypenameWithoutSpreadsAbstractType";
};
export type TypenameWithoutSpreadsAbstractType$data = TypenameWithoutSpreadsAbstractType;
export type TypenameWithoutSpreadsAbstractType$key = {
    readonly " $data"?: TypenameWithoutSpreadsAbstractType$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithoutSpreadsAbstractType">;
};


// TypenameWithCommonSelections.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithCommonSelections = {
    readonly __typename: string;
    readonly name: string | null;
    readonly firstName?: string | null;
    readonly username?: string | null;
    readonly " $refType": "TypenameWithCommonSelections";
};
export type TypenameWithCommonSelections$data = TypenameWithCommonSelections;
export type TypenameWithCommonSelections$key = {
    readonly " $data"?: TypenameWithCommonSelections$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithCommonSelections">;
};


// TypenameAlias.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameAlias = {
    readonly _typeAlias: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameAlias";
} | {
    readonly _typeAlias: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameAlias";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias: "%other";
    readonly " $refType": "TypenameAlias";
};
export type TypenameAlias$data = TypenameAlias;
export type TypenameAlias$key = {
    readonly " $data"?: TypenameAlias$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameAlias">;
};


// TypenameAliases.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameAliases = {
    readonly _typeAlias1: "User";
    readonly _typeAlias2: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameAliases";
} | {
    readonly _typeAlias1: "Page";
    readonly _typeAlias2: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameAliases";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias1: "%other";
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias2: "%other";
    readonly " $refType": "TypenameAliases";
};
export type TypenameAliases$data = TypenameAliases;
export type TypenameAliases$key = {
    readonly " $data"?: TypenameAliases$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameAliases">;
};

`;

exports[`Snapshot tests TypeScriptGenerator with a single artifact directory matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// UserProfile.graphql
import { FragmentRefs } from "relay-runtime";
export type UserProfile = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
        readonly " $fragmentRefs": FragmentRefs<"PhotoFragment">;
    } | null;
    readonly " $refType": "UserProfile";
};
export type UserProfile$data = UserProfile;
export type UserProfile$key = {
    readonly " $data"?: UserProfile$data;
    readonly " $fragmentRefs": FragmentRefs<"UserProfile">;
};


// PhotoFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PhotoFragment = {
    readonly uri: string | null;
    readonly width: number | null;
    readonly " $refType": "PhotoFragment";
};
export type PhotoFragment$data = PhotoFragment;
export type PhotoFragment$key = {
    readonly " $data"?: PhotoFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PhotoFragment">;
};


// RecursiveFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type RecursiveFragment = {
    readonly uri: string | null;
    readonly width: number | null;
};
export type RecursiveFragment$data = RecursiveFragment;
export type RecursiveFragment$key = {
    readonly " $data"?: RecursiveFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"RecursiveFragment">;
};


// AnotherRecursiveFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type AnotherRecursiveFragment = {
    readonly uri: string | null;
    readonly height: number | null;
    readonly " $refType": "AnotherRecursiveFragment";
};
export type AnotherRecursiveFragment$data = AnotherRecursiveFragment;
export type AnotherRecursiveFragment$key = {
    readonly " $data"?: AnotherRecursiveFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"AnotherRecursiveFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ConditionField.graphql
import { FragmentRefs } from "relay-runtime";
export type ConditionField = {
    readonly id?: string;
    readonly " $refType": "ConditionField";
};
export type ConditionField$data = ConditionField;
export type ConditionField$key = {
    readonly " $data"?: ConditionField$data;
    readonly " $fragmentRefs": FragmentRefs<"ConditionField">;
};


// NestedCondition.graphql
import { FragmentRefs } from "relay-runtime";
export type NestedCondition = {
    readonly id?: string;
    readonly " $refType": "NestedCondition";
};
export type NestedCondition$data = NestedCondition;
export type NestedCondition$key = {
    readonly " $data"?: NestedCondition$data;
    readonly " $fragmentRefs": FragmentRefs<"NestedCondition">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: derived-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query QueryWithConnectionField($id: ID!) {
  feedback: node(id: $id) {
    ...FeedbackComments_feedback
  }
}

fragment FeedbackComments_feedback on Feedback {
  comments(first: 10) @connection_resolver(label: "FeedbackComments_feedback") {
    count
    edges {
      node {
        id
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// QueryWithConnectionField.graphql
import { FragmentRefs } from "relay-runtime";
export type QueryWithConnectionFieldVariables = {
    id: string;
};
export type QueryWithConnectionFieldResponse = {
    readonly feedback: {
        readonly " $fragmentRefs": FragmentRefs<"FeedbackComments_feedback">;
    } | null;
};
export type QueryWithConnectionField = {
    readonly response: QueryWithConnectionFieldResponse;
    readonly variables: QueryWithConnectionFieldVariables;
};


// FeedbackComments_feedback.graphql
import { FragmentRefs } from "relay-runtime";
export type FeedbackComments_feedback = {
    readonly comments: {
        readonly count: number | null;
        readonly __connection?: ConnectionReference<{
            readonly node: {
                readonly id: string;
                readonly __id: string;
            } | null;
            readonly __id: string;
        }>;
    } | null;
    readonly " $refType": "FeedbackComments_feedback";
};
export type FeedbackComments_feedback$data = FeedbackComments_feedback;
export type FeedbackComments_feedback$key = {
    readonly " $data"?: FeedbackComments_feedback$data;
    readonly " $fragmentRefs": FragmentRefs<"FeedbackComments_feedback">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on User {
  __typename
}

fragment UserFrag2 on User {
  __typename
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import { FragmentRefs } from "relay-runtime";
export type FragmentSpread = {
    readonly id: string;
    readonly justFrag: {
        readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
    } | null;
    readonly fragAndField: {
        readonly uri: string | null;
        readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
    } | null;
    readonly " $fragmentRefs": FragmentRefs<"OtherFragment" | "UserFrag1" | "UserFrag2">;
    readonly " $refType": "FragmentSpread";
};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
    readonly " $data"?: FragmentSpread$data;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
};


// ConcreateTypes.graphql
import { FragmentRefs } from "relay-runtime";
export type ConcreateTypes = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly " $fragmentRefs": FragmentRefs<"PageFragment">;
    } | {
        readonly __typename: "User";
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": "ConcreateTypes";
};
export type ConcreateTypes$data = ConcreateTypes;
export type ConcreateTypes$key = {
    readonly " $data"?: ConcreateTypes$data;
    readonly " $fragmentRefs": FragmentRefs<"ConcreateTypes">;
};


// PictureFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PictureFragment = {
    readonly __typename: "Image";
    readonly " $refType": "PictureFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "PictureFragment";
};
export type PictureFragment$data = PictureFragment;
export type PictureFragment$key = {
    readonly " $data"?: PictureFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PictureFragment">;
};


// OtherFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type OtherFragment = {
    readonly __typename: string;
    readonly " $refType": "OtherFragment";
};
export type OtherFragment$data = OtherFragment;
export type OtherFragment$key = {
    readonly " $data"?: OtherFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"OtherFragment">;
};


// PageFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PageFragment = {
    readonly __typename: "Page";
    readonly " $refType": "PageFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "PageFragment";
};
export type PageFragment$data = PageFragment;
export type PageFragment$key = {
    readonly " $data"?: PageFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PageFragment">;
};


// UserFrag1.graphql
import { FragmentRefs } from "relay-runtime";
export type UserFrag1 = {
    readonly __typename: "User";
    readonly " $refType": "UserFrag1";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "UserFrag1";
};
export type UserFrag1$data = UserFrag1;
export type UserFrag1$key = {
    readonly " $data"?: UserFrag1$data;
    readonly " $fragmentRefs": FragmentRefs<"UserFrag1">;
};


// UserFrag2.graphql
import { FragmentRefs } from "relay-runtime";
export type UserFrag2 = {
    readonly __typename: "User";
    readonly " $refType": "UserFrag2";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "UserFrag2";
};
export type UserFrag2$data = UserFrag2;
export type UserFrag2$key = {
    readonly " $data"?: UserFrag2$data;
    readonly " $fragmentRefs": FragmentRefs<"UserFrag2">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InlineFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragment = {
    readonly id: string;
    readonly name?: string | null;
    readonly message?: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "InlineFragment";
};
export type InlineFragment$data = InlineFragment;
export type InlineFragment$key = {
    readonly " $data"?: InlineFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragment">;
};


// InlineFragmentWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentWithOverlappingFields";
};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
    readonly " $data"?: InlineFragmentWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
};


// InlineFragmentConditionalID.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentConditionalID = {
    readonly id?: string;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentConditionalID";
};
export type InlineFragmentConditionalID$data = InlineFragmentConditionalID;
export type InlineFragmentConditionalID$key = {
    readonly " $data"?: InlineFragmentConditionalID$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentConditionalID">;
};


// InlineFragmentKitchenSink.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentKitchenSink = {
    readonly actor: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
            readonly width?: number | null;
            readonly height?: number | null;
        } | null;
        readonly name?: string | null;
        readonly " $fragmentRefs": FragmentRefs<"SomeFragment">;
    } | null;
    readonly " $refType": "InlineFragmentKitchenSink";
};
export type InlineFragmentKitchenSink$data = InlineFragmentKitchenSink;
export type InlineFragmentKitchenSink$key = {
    readonly " $data"?: InlineFragmentKitchenSink$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentKitchenSink">;
};


// SomeFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type SomeFragment = {
    readonly __typename: "User";
    readonly " $refType": "SomeFragment";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "SomeFragment";
};
export type SomeFragment$data = SomeFragment;
export type SomeFragment$key = {
    readonly " $data"?: SomeFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"SomeFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedField.graphql
import { FragmentRefs } from "relay-runtime";
export type LinkedField = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
    } | null;
    readonly hometown: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
        } | null;
    } | null;
    readonly actor: {
        readonly id: string;
    } | null;
    readonly " $refType": "LinkedField";
};
export type LinkedField$data = LinkedField;
export type LinkedField$key = {
    readonly " $data"?: LinkedField$data;
    readonly " $fragmentRefs": FragmentRefs<"LinkedField">;
};


// UnionTypeTest.graphql
export type UnionTypeTestVariables = {};
export type UnionTypeTestResponse = {
    readonly neverNode: ({
        readonly __typename: "FakeNode";
        readonly id: string;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
};
export type UnionTypeTest = {
    readonly response: UnionTypeTestResponse;
    readonly variables: UnionTypeTestVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type NameRendererFragment = {
    readonly id: string;
    readonly nameRenderer: {
        readonly __fragmentPropName?: string | null;
        readonly __module_component?: string | null;
        readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name" | "MarkdownUserNameRenderer_name">;
    } | null;
    readonly " $refType": "NameRendererFragment";
};
export type NameRendererFragment$data = NameRendererFragment;
export type NameRendererFragment$key = {
    readonly " $data"?: NameRendererFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"NameRendererFragment">;
};


// PlainUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "PlainUserNameRenderer_name";
};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
    readonly " $data"?: PlainUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name">;
};


// MarkdownUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": "MarkdownUserNameRenderer_name";
};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
    readonly " $data"?: MarkdownUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"MarkdownUserNameRenderer_name">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererQuery.graphql
import { FragmentRefs } from "relay-runtime";
export type NameRendererQueryVariables = {};
export type NameRendererQueryResponse = {
    readonly me: {
        readonly nameRenderer: {
            readonly __fragmentPropName?: string | null;
            readonly __module_component?: string | null;
            readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name" | "MarkdownUserNameRenderer_name">;
        } | null;
    } | null;
};
export type NameRendererQuery = {
    readonly response: NameRendererQueryResponse;
    readonly variables: NameRendererQueryVariables;
};


// PlainUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": "PlainUserNameRenderer_name";
};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
    readonly " $data"?: PlainUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"PlainUserNameRenderer_name">;
};


// MarkdownUserNameRenderer_name.graphql
import { FragmentRefs } from "relay-runtime";
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": "MarkdownUserNameRenderer_name";
};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
    readonly " $data"?: MarkdownUserNameRenderer_name$data;
    readonly " $fragmentRefs": FragmentRefs<"MarkdownUserNameRenderer_name">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) {
  commentCreate(input: $input) {
    comment {
      id
      name
      friends(first: $first, orderby: $orderBy) {
        count
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
            readonly name: string | null;
            readonly friends: {
                readonly count: number | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InputHasArray.graphql
export type UpdateAllSeenStateInput = {
    readonly clientMutationId?: string | null;
    readonly storyIds?: ReadonlyArray<string | null> | null;
};
export type InputHasArrayVariables = {
    input?: UpdateAllSeenStateInput | null;
};
export type InputHasArrayResponse = {
    readonly viewerNotificationsUpdateAllSeenState: {
        readonly stories: ReadonlyArray<{
            readonly actorCount: number | null;
        } | null> | null;
    } | null;
};
export type InputHasArrayRawResponse = {
    readonly viewerNotificationsUpdateAllSeenState: ({
        readonly stories: ReadonlyArray<({
            readonly actorCount: number | null;
            readonly id: string | null;
        }) | null> | null;
    }) | null;
};
export type InputHasArray = {
    readonly response: InputHasArrayResponse;
    readonly variables: InputHasArrayVariables;
    readonly rawResponse: InputHasArrayRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
export type UpdateAllSeenStateInput = {
    readonly clientMutationId?: string | null;
    readonly storyIds?: ReadonlyArray<string | null> | null;
};
export type TestVariables = {
    input?: UpdateAllSeenStateInput | null;
};
export type TestResponse = {
    readonly viewerNotificationsUpdateAllSeenState: {
        readonly stories: ReadonlyArray<{
            readonly foos: ReadonlyArray<{
                readonly bar: string | null;
            } | null> | null;
        } | null> | null;
    } | null;
};
export type TestRawResponse = {
    readonly viewerNotificationsUpdateAllSeenState: ({
        readonly stories: ReadonlyArray<({
            readonly id: string | null;
            readonly foos?: ReadonlyArray<({
                readonly bar: string | null;
            }) | null> | null;
        }) | null> | null;
    }) | null;
};
export type Test = {
    readonly response: TestResponse;
    readonly variables: TestVariables;
    readonly rawResponse: TestRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-enums-on-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            id
            __typename
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  profilePicture2 {
    test_enums
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type TestEnums = "mark" | "zuck" | "%future added value";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly friends: {
                readonly edges: ReadonlyArray<{
                    readonly node: {
                        readonly id: string;
                        readonly __typename: string;
                        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
                    } | null;
                } | null> | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutationRawResponse = {
    readonly commentCreate: ({
        readonly comment: ({
            readonly friends: ({
                readonly edges: ReadonlyArray<({
                    readonly node: ({
                        readonly id: string;
                        readonly __typename: "User";
                        readonly name: string | null;
                        readonly lastName: string | null;
                        readonly profilePicture2: ({
                            readonly test_enums: TestEnums | null;
                        }) | null;
                    }) | null;
                }) | null> | null;
            }) | null;
            readonly id: string | null;
        }) | null;
    }) | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
    readonly rawResponse: CommentCreateMutationRawResponse;
};


// FriendFragment.graphql
export type TestEnums = "mark" | "zuck" | "%future added value";
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name: string | null;
    readonly lastName: string | null;
    readonly profilePicture2: {
        readonly test_enums: TestEnums | null;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-nested-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            lastName
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  feedback {
    ...FeedbackFragment
  }
}

fragment FeedbackFragment on Feedback {
  id
  name
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    input: CommentCreateInput;
    first?: number | null;
    orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly friends: {
                readonly edges: ReadonlyArray<{
                    readonly node: {
                        readonly lastName: string | null;
                        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
                    } | null;
                } | null> | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutationRawResponse = {
    readonly commentCreate: ({
        readonly comment: ({
            readonly friends: ({
                readonly edges: ReadonlyArray<({
                    readonly node: ({
                        readonly lastName: string | null;
                        readonly name: string | null;
                        readonly feedback: ({
                            readonly id: string;
                            readonly name: string | null;
                        }) | null;
                        readonly id: string | null;
                    }) | null;
                }) | null> | null;
            }) | null;
            readonly id: string | null;
        }) | null;
    }) | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
    readonly rawResponse: CommentCreateMutationRawResponse;
};


// FriendFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name: string | null;
    readonly lastName: string | null;
    readonly feedback: {
        readonly " $fragmentRefs": FragmentRefs<"FeedbackFragment">;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};


// FeedbackFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FeedbackFragment = {
    readonly id: string;
    readonly name: string | null;
    readonly " $refType": "FeedbackFragment";
};
export type FeedbackFragment$data = FeedbackFragment;
export type FeedbackFragment$key = {
    readonly " $data"?: FeedbackFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FeedbackFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-response-on-inline-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
  commentCreate(input: $input) {
    viewer {
      actor {
        ...InlineFragmentWithOverlappingFields
      }
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestMutation.graphql
import { FragmentRefs } from "relay-runtime";
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly viewer: {
            readonly actor: {
                readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
            } | null;
        } | null;
    } | null;
};
export type TestMutationRawResponse = {
    readonly commentCreate: ({
        readonly viewer: ({
            readonly actor: ({
                readonly __typename: "User";
                readonly id: string | null;
                readonly hometown: ({
                    readonly id: string;
                    readonly name: string | null;
                }) | null;
            } | {
                readonly __typename: "Page";
                readonly id: string | null;
                readonly name: string | null;
                readonly hometown: ({
                    readonly id: string;
                    readonly message: ({
                        readonly text: string | null;
                    }) | null;
                }) | null;
            } | {
                readonly __typename: string | null;
                readonly id: string | null;
            }) | null;
        }) | null;
    }) | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
    readonly rawResponse: TestMutationRawResponse;
};


// InlineFragmentWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": "InlineFragmentWithOverlappingFields";
};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
    readonly " $data"?: InlineFragmentWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"InlineFragmentWithOverlappingFields">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// PluralFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PluralFragment = ReadonlyArray<{
    readonly id: string;
    readonly " $refType": "PluralFragment";
}>;
export type PluralFragment$data = PluralFragment;
export type PluralFragment$key = ReadonlyArray<{
    readonly " $data"?: PluralFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PluralFragment">;
}>;

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: query-with-defer.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(key: "TestDefer_friends", initial_count: 0) {
        edges {
          node {
            actor {
              name
            }
          }
        }
      }
    }
  }
}
~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestDefer.graphql
export type TestDeferVariables = {};
export type TestDeferResponse = {
    readonly node: {
        readonly name?: string | null;
        readonly friends?: {
            readonly edges: ReadonlyArray<{
                readonly node: {
                    readonly actor: {
                        readonly name: string | null;
                    } | null;
                } | null;
            } | null> | null;
        } | null;
    } | null;
};
export type TestDeferRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
        readonly friends: ({
            readonly edges: ReadonlyArray<({
                readonly node: ({
                    readonly actor: ({
                        readonly __typename: string | null;
                        readonly name: string | null;
                        readonly id: string | null;
                    }) | null;
                    readonly id: string | null;
                    readonly __typename: "User";
                }) | null;
                readonly cursor: string | null;
            }) | null> | null;
            readonly pageInfo: ({
                readonly endCursor: string | null;
                readonly hasNextPage: boolean | null;
            }) | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type TestDefer = {
    readonly response: TestDeferResponse;
    readonly variables: TestDeferVariables;
    readonly rawResponse: TestDeferRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedHandleField.graphql
export type LinkedHandleFieldVariables = {
    id: string;
};
export type LinkedHandleFieldResponse = {
    readonly node: {
        readonly friends?: {
            readonly count: number | null;
        } | null;
    } | null;
};
export type LinkedHandleFieldRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly friends: ({
            readonly count: number | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type LinkedHandleField = {
    readonly response: LinkedHandleFieldResponse;
    readonly variables: LinkedHandleFieldVariables;
    readonly rawResponse: LinkedHandleFieldRawResponse;
};


// ScalarHandleField.graphql
export type ScalarHandleFieldVariables = {
    id: string;
};
export type ScalarHandleFieldResponse = {
    readonly node: {
        readonly name?: string | null;
    } | null;
};
export type ScalarHandleFieldRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type ScalarHandleField = {
    readonly response: ScalarHandleFieldResponse;
    readonly variables: ScalarHandleFieldVariables;
    readonly rawResponse: ScalarHandleFieldRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
import { FragmentRefs } from "relay-runtime";
export type ExampleQueryVariables = {
    id: string;
    condition: boolean;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
    } | null;
};
export type ExampleQueryRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name?: string | null;
        readonly lastName?: string | null;
        readonly feedback?: ({
            readonly id: string;
            readonly name: string | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
    readonly rawResponse: ExampleQueryRawResponse;
};


// FriendFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type FriendFragment = {
    readonly name?: string | null;
    readonly lastName?: string | null;
    readonly feedback?: {
        readonly id: string;
        readonly name: string | null;
    } | null;
    readonly " $refType": "FriendFragment";
};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
    readonly " $data"?: FriendFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"FriendFragment">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestStream.graphql
export type TestStreamVariables = {};
export type TestStreamResponse = {
    readonly node: {
        readonly name?: string | null;
        readonly friends?: {
            readonly edges: ReadonlyArray<{
                readonly node: {
                    readonly id: string;
                } | null;
            } | null> | null;
        } | null;
    } | null;
};
export type TestStreamRawResponse = {
    readonly node: ({
        readonly __typename: "User";
        readonly id: string | null;
        readonly name: string | null;
        readonly friends: ({
            readonly edges: ReadonlyArray<({
                readonly node: ({
                    readonly id: string;
                    readonly __typename: "User";
                }) | null;
                readonly cursor: string | null;
            }) | null> | null;
            readonly pageInfo: ({
                readonly endCursor: string | null;
                readonly hasNextPage: boolean | null;
            }) | null;
        }) | null;
    } | {
        readonly __typename: string | null;
        readonly id: string | null;
    }) | null;
};
export type TestStream = {
    readonly response: TestStreamResponse;
    readonly variables: TestStreamVariables;
    readonly rawResponse: TestStreamRawResponse;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import { FragmentRefs } from "relay-runtime";
export type FragmentSpread = {
    readonly id: string;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
    readonly " $refType": "FragmentSpread";
};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
    readonly " $data"?: FragmentSpread$data;
    readonly " $fragmentRefs": FragmentRefs<"FragmentSpread">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type RefetchableFragment = {
    readonly id: string;
    readonly fragAndField: {
        readonly uri: string | null;
    } | null;
    readonly " $refType": "RefetchableFragment";
};
export type RefetchableFragment$data = RefetchableFragment;
export type RefetchableFragment$key = {
    readonly " $data"?: RefetchableFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"RefetchableFragment">;
};


// RefetchableFragmentQuery.graphql
import { FragmentRefs } from "relay-runtime";
export type RefetchableFragmentQueryVariables = {
    id: string;
};
export type RefetchableFragmentQueryResponse = {
    readonly node: {
        readonly " $fragmentRefs": FragmentRefs<"RefetchableFragment">;
    } | null;
};
export type RefetchableFragmentQuery = {
    readonly response: RefetchableFragmentQueryResponse;
    readonly variables: RefetchableFragmentQueryVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: roots.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) {
  node(id: $id) {
    id
  }
}

fragment ExampleFragment on User {
  id
}

mutation TestMutation($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    comment {
      id
    }
  }
}

subscription TestSubscription($input: FeedbackLikeInput) {
  feedbackLikeSubscribe(input: $input) {
    feedback {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
export type ExampleQueryVariables = {
    id: string;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly id: string;
    } | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
};


// ExampleFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type ExampleFragment = {
    readonly id: string;
    readonly " $refType": "ExampleFragment";
};
export type ExampleFragment$data = ExampleFragment;
export type ExampleFragment$key = {
    readonly " $data"?: ExampleFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"ExampleFragment">;
};


// TestMutation.graphql
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
};


// TestSubscription.graphql
export type FeedbackLikeInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
};
export type TestSubscriptionVariables = {
    input?: FeedbackLikeInput | null;
};
export type TestSubscriptionResponse = {
    readonly feedbackLikeSubscribe: {
        readonly feedback: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestSubscription = {
    readonly response: TestSubscriptionResponse;
    readonly variables: TestSubscriptionVariables;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ScalarField.graphql
export type PersonalityTraits = "CHEERFUL" | "DERISIVE" | "HELPFUL" | "SNARKY" | "%future added value";
import { FragmentRefs } from "relay-runtime";
export type ScalarField = {
    readonly id: string;
    readonly name: string | null;
    readonly websites: ReadonlyArray<string | null> | null;
    readonly traits: ReadonlyArray<PersonalityTraits | null> | null;
    readonly aliasedLinkedField: {
        readonly aliasedField: number | null;
    } | null;
    readonly screennames: ReadonlyArray<{
        readonly name: string | null;
        readonly service: string | null;
    } | null> | null;
    readonly " $refType": "ScalarField";
};
export type ScalarField$data = ScalarField;
export type ScalarField$key = {
    readonly " $data"?: ScalarField$data;
    readonly " $fragmentRefs": FragmentRefs<"ScalarField">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInsideWithOverlappingFields.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameInsideWithOverlappingFields = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": "TypenameInsideWithOverlappingFields";
};
export type TypenameInsideWithOverlappingFields$data = TypenameInsideWithOverlappingFields;
export type TypenameInsideWithOverlappingFields$key = {
    readonly " $data"?: TypenameInsideWithOverlappingFields$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameInsideWithOverlappingFields">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInside.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameInside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameInside";
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameInside";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "TypenameInside";
};
export type TypenameInside$data = TypenameInside;
export type TypenameInside$key = {
    readonly " $data"?: TypenameInside$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameInside">;
};


// TypenameOutside.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameOutside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameOutside";
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameOutside";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": "TypenameOutside";
};
export type TypenameOutside$data = TypenameOutside;
export type TypenameOutside$key = {
    readonly " $data"?: TypenameOutside$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameOutside">;
};


// TypenameOutsideWithAbstractType.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameOutsideWithAbstractType = {
    readonly __typename: string;
    readonly username?: string | null;
    readonly address?: {
        readonly city: string | null;
        readonly country: string | null;
        readonly street?: string | null;
    } | null;
    readonly firstName?: string | null;
    readonly " $refType": "TypenameOutsideWithAbstractType";
};
export type TypenameOutsideWithAbstractType$data = TypenameOutsideWithAbstractType;
export type TypenameOutsideWithAbstractType$key = {
    readonly " $data"?: TypenameOutsideWithAbstractType$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameOutsideWithAbstractType">;
};


// TypenameWithoutSpreads.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithoutSpreads = {
    readonly firstName: string | null;
    readonly __typename: "User";
    readonly " $refType": "TypenameWithoutSpreads";
};
export type TypenameWithoutSpreads$data = TypenameWithoutSpreads;
export type TypenameWithoutSpreads$key = {
    readonly " $data"?: TypenameWithoutSpreads$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithoutSpreads">;
};


// TypenameWithoutSpreadsAbstractType.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithoutSpreadsAbstractType = {
    readonly __typename: string;
    readonly id: string;
    readonly " $refType": "TypenameWithoutSpreadsAbstractType";
};
export type TypenameWithoutSpreadsAbstractType$data = TypenameWithoutSpreadsAbstractType;
export type TypenameWithoutSpreadsAbstractType$key = {
    readonly " $data"?: TypenameWithoutSpreadsAbstractType$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithoutSpreadsAbstractType">;
};


// TypenameWithCommonSelections.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameWithCommonSelections = {
    readonly __typename: string;
    readonly name: string | null;
    readonly firstName?: string | null;
    readonly username?: string | null;
    readonly " $refType": "TypenameWithCommonSelections";
};
export type TypenameWithCommonSelections$data = TypenameWithCommonSelections;
export type TypenameWithCommonSelections$key = {
    readonly " $data"?: TypenameWithCommonSelections$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameWithCommonSelections">;
};


// TypenameAlias.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameAlias = {
    readonly _typeAlias: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameAlias";
} | {
    readonly _typeAlias: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameAlias";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias: "%other";
    readonly " $refType": "TypenameAlias";
};
export type TypenameAlias$data = TypenameAlias;
export type TypenameAlias$key = {
    readonly " $data"?: TypenameAlias$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameAlias">;
};


// TypenameAliases.graphql
import { FragmentRefs } from "relay-runtime";
export type TypenameAliases = {
    readonly _typeAlias1: "User";
    readonly _typeAlias2: "User";
    readonly firstName: string | null;
    readonly " $refType": "TypenameAliases";
} | {
    readonly _typeAlias1: "Page";
    readonly _typeAlias2: "Page";
    readonly username: string | null;
    readonly " $refType": "TypenameAliases";
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias1: "%other";
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias2: "%other";
    readonly " $refType": "TypenameAliases";
};
export type TypenameAliases$data = TypenameAliases;
export type TypenameAliases$key = {
    readonly " $data"?: TypenameAliases$data;
    readonly " $fragmentRefs": FragmentRefs<"TypenameAliases">;
};

`;

exports[`Snapshot tests TypeScriptGenerator without a single artifact directory matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// UserProfile.graphql
import { FragmentRefs } from "relay-runtime";
export type UserProfile = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
        readonly " $fragmentRefs": FragmentRefs<"PhotoFragment">;
    } | null;
    readonly " $refType": "UserProfile";
};
export type UserProfile$data = UserProfile;
export type UserProfile$key = {
    readonly " $data"?: UserProfile$data;
    readonly " $fragmentRefs": FragmentRefs<"UserProfile">;
};


// PhotoFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type PhotoFragment = {
    readonly uri: string | null;
    readonly width: number | null;
    readonly " $refType": "PhotoFragment";
};
export type PhotoFragment$data = PhotoFragment;
export type PhotoFragment$key = {
    readonly " $data"?: PhotoFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"PhotoFragment">;
};


// RecursiveFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type RecursiveFragment = {
    readonly uri: string | null;
    readonly width: number | null;
};
export type RecursiveFragment$data = RecursiveFragment;
export type RecursiveFragment$key = {
    readonly " $data"?: RecursiveFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"RecursiveFragment">;
};


// AnotherRecursiveFragment.graphql
import { FragmentRefs } from "relay-runtime";
export type AnotherRecursiveFragment = {
    readonly uri: string | null;
    readonly height: number | null;
    readonly " $refType": "AnotherRecursiveFragment";
};
export type AnotherRecursiveFragment$data = AnotherRecursiveFragment;
export type AnotherRecursiveFragment$key = {
    readonly " $data"?: AnotherRecursiveFragment$data;
    readonly " $fragmentRefs": FragmentRefs<"AnotherRecursiveFragment">;
};

`;
